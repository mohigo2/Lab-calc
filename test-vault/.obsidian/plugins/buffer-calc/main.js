/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/types.ts
var types_exports = {};
__export(types_exports, {
  CONCENTRATION_CONVERSION_FACTORS: () => CONCENTRATION_CONVERSION_FACTORS,
  ConcentrationUnit: () => ConcentrationUnit,
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  ErrorType: () => ErrorType,
  MASS_CONVERSION_FACTORS: () => MASS_CONVERSION_FACTORS,
  MassUnit: () => MassUnit,
  VOLUME_CONVERSION_FACTORS: () => VOLUME_CONVERSION_FACTORS,
  VolumeUnit: () => VolumeUnit,
  WarningType: () => WarningType
});
var VolumeUnit, ConcentrationUnit, MassUnit, WarningType, ErrorType, DEFAULT_SETTINGS, VOLUME_CONVERSION_FACTORS, MASS_CONVERSION_FACTORS, CONCENTRATION_CONVERSION_FACTORS;
var init_types = __esm({
  "src/types.ts"() {
    VolumeUnit = /* @__PURE__ */ ((VolumeUnit2) => {
      VolumeUnit2["LITER"] = "L";
      VolumeUnit2["MILLILITER"] = "mL";
      VolumeUnit2["MICROLITER"] = "\xB5L";
      VolumeUnit2["NANOLITER"] = "nL";
      return VolumeUnit2;
    })(VolumeUnit || {});
    ConcentrationUnit = /* @__PURE__ */ ((ConcentrationUnit2) => {
      ConcentrationUnit2["MOLAR"] = "M";
      ConcentrationUnit2["MILLIMOLAR"] = "mM";
      ConcentrationUnit2["MICROMOLAR"] = "\xB5M";
      ConcentrationUnit2["NANOMOLAR"] = "nM";
      ConcentrationUnit2["PERCENT_W_V"] = "%(w/v)";
      ConcentrationUnit2["PERCENT_W_W"] = "%(w/w)";
      ConcentrationUnit2["PERCENT_V_V"] = "%(v/v)";
      ConcentrationUnit2["MG_ML"] = "mg/mL";
      ConcentrationUnit2["UG_ML"] = "\xB5g/mL";
      ConcentrationUnit2["PPM"] = "ppm";
      ConcentrationUnit2["PPB"] = "ppb";
      return ConcentrationUnit2;
    })(ConcentrationUnit || {});
    MassUnit = /* @__PURE__ */ ((MassUnit2) => {
      MassUnit2["GRAM"] = "g";
      MassUnit2["MILLIGRAM"] = "mg";
      MassUnit2["MICROGRAM"] = "\xB5g";
      MassUnit2["NANOGRAM"] = "ng";
      return MassUnit2;
    })(MassUnit || {});
    WarningType = /* @__PURE__ */ ((WarningType2) => {
      WarningType2["HIGH_CONCENTRATION"] = "high_concentration";
      WarningType2["LOW_CONCENTRATION"] = "low_concentration";
      WarningType2["SMALL_VOLUME"] = "small_volume";
      WarningType2["LARGE_VOLUME"] = "large_volume";
      WarningType2["MISSING_MOLECULAR_WEIGHT"] = "missing_molecular_weight";
      WarningType2["UNUSUAL_DILUTION_FACTOR"] = "unusual_dilution_factor";
      WarningType2["OLD_REAGENT"] = "old_reagent";
      WarningType2["VOLUME_OVERFLOW"] = "volume_overflow";
      return WarningType2;
    })(WarningType || {});
    ErrorType = /* @__PURE__ */ ((ErrorType2) => {
      ErrorType2["IMPOSSIBLE_CONCENTRATION"] = "impossible_concentration";
      ErrorType2["NEGATIVE_VALUE"] = "negative_value";
      ErrorType2["MISSING_REQUIRED_FIELD"] = "missing_required_field";
      ErrorType2["INVALID_MOLECULAR_WEIGHT"] = "invalid_molecular_weight";
      ErrorType2["CONCENTRATION_UNIT_MISMATCH"] = "concentration_unit_mismatch";
      ErrorType2["VOLUME_OVERFLOW"] = "volume_overflow";
      ErrorType2["CALCULATION_ERROR"] = "calculation_error";
      return ErrorType2;
    })(ErrorType || {});
    DEFAULT_SETTINGS = {
      defaultVolumeUnit: "mL" /* MILLILITER */,
      defaultConcentrationUnit: "mM" /* MILLIMOLAR */,
      decimalPlaces: 2,
      enableSuggestions: true,
      showCalculationSteps: false,
      customReagents: [],
      defaultTemplate: "buffer"
    };
    VOLUME_CONVERSION_FACTORS = {
      ["L" /* LITER */]: 1,
      ["mL" /* MILLILITER */]: 1e3,
      ["\xB5L" /* MICROLITER */]: 1e6,
      ["nL" /* NANOLITER */]: 1e9
    };
    MASS_CONVERSION_FACTORS = {
      ["g" /* GRAM */]: 1,
      ["mg" /* MILLIGRAM */]: 1e3,
      ["\xB5g" /* MICROGRAM */]: 1e6,
      ["ng" /* NANOGRAM */]: 1e9
    };
    CONCENTRATION_CONVERSION_FACTORS = {
      ["M" /* MOLAR */]: 1,
      ["mM" /* MILLIMOLAR */]: 1e3,
      ["\xB5M" /* MICROMOLAR */]: 1e6,
      ["nM" /* NANOMOLAR */]: 1e9,
      ["%(w/v)" /* PERCENT_W_V */]: 1,
      ["%(w/w)" /* PERCENT_W_W */]: 1,
      ["%(v/v)" /* PERCENT_V_V */]: 1,
      ["mg/mL" /* MG_ML */]: 1,
      ["\xB5g/mL" /* UG_ML */]: 1e3,
      ["ppm" /* PPM */]: 1e6,
      ["ppb" /* PPB */]: 1e9
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BufferCalcPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
init_types();

// src/settings.ts
var import_obsidian = require("obsidian");
init_types();
var BufferCalcSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Buffer Calc Settings" });
    this.addGeneralSettings();
    this.addUnitsSettings();
    this.addDisplaySettings();
    this.addReagentSettings();
    this.addDataManagement();
  }
  addGeneralSettings() {
    const { containerEl } = this;
    containerEl.createEl("h2", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable auto-suggestions").setDesc("Enable reagent name suggestions while typing").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableSuggestions).onChange(async (value) => {
        this.plugin.settings.enableSuggestions = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show calculation steps").setDesc("Display detailed calculation steps in results").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showCalculationSteps).onChange(async (value) => {
        this.plugin.settings.showCalculationSteps = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Decimal places").setDesc("Number of decimal places to show in results").addSlider((slider) => {
      slider.setLimits(0, 5, 1).setValue(this.plugin.settings.decimalPlaces).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.decimalPlaces = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addUnitsSettings() {
    const { containerEl } = this;
    containerEl.createEl("h2", { text: "Default Units" });
    new import_obsidian.Setting(containerEl).setName("Default volume unit").setDesc("Default unit for volumes in calculations").addDropdown((dropdown) => {
      const options = {
        ["L" /* LITER */]: "Liter (L)",
        ["mL" /* MILLILITER */]: "Milliliter (mL)",
        ["\xB5L" /* MICROLITER */]: "Microliter (\xB5L)",
        ["nL" /* NANOLITER */]: "Nanoliter (nL)"
      };
      for (const [key, value] of Object.entries(options)) {
        dropdown.addOption(key, value);
      }
      dropdown.setValue(this.plugin.settings.defaultVolumeUnit).onChange(async (value) => {
        this.plugin.settings.defaultVolumeUnit = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default concentration unit").setDesc("Default unit for concentrations in calculations").addDropdown((dropdown) => {
      const options = {
        ["M" /* MOLAR */]: "Molar (M)",
        ["mM" /* MILLIMOLAR */]: "Millimolar (mM)",
        ["\xB5M" /* MICROMOLAR */]: "Micromolar (\xB5M)",
        ["nM" /* NANOMOLAR */]: "Nanomolar (nM)",
        ["%(w/v)" /* PERCENT_W_V */]: "Percent (w/v)",
        ["%(w/w)" /* PERCENT_W_W */]: "Percent (w/w)",
        ["%(v/v)" /* PERCENT_V_V */]: "Percent (v/v)",
        ["mg/mL" /* MG_ML */]: "mg/mL",
        ["\xB5g/mL" /* UG_ML */]: "\xB5g/mL"
      };
      for (const [key, value] of Object.entries(options)) {
        dropdown.addOption(key, value);
      }
      dropdown.setValue(this.plugin.settings.defaultConcentrationUnit).onChange(async (value) => {
        this.plugin.settings.defaultConcentrationUnit = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addDisplaySettings() {
    const { containerEl } = this;
    containerEl.createEl("h2", { text: "Display Settings" });
    new import_obsidian.Setting(containerEl).setName("Default template").setDesc("Default template for new buffer calculations").addDropdown((dropdown) => {
      dropdown.addOption("buffer", "Buffer Preparation");
      dropdown.addOption("stock", "Stock Solution");
      dropdown.addOption("dilution", "Serial Dilution");
      dropdown.setValue(this.plugin.settings.defaultTemplate).onChange(async (value) => {
        this.plugin.settings.defaultTemplate = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addReagentSettings() {
    const { containerEl } = this;
    containerEl.createEl("h2", { text: "Custom Reagents" });
    const reagentContainer = containerEl.createEl("div", { cls: "buffer-calc-reagent-list" });
    const updateReagentList = () => {
      reagentContainer.empty();
      if (this.plugin.settings.customReagents.length === 0) {
        reagentContainer.createEl("p", {
          text: "No custom reagents added yet.",
          cls: "buffer-calc-no-reagents"
        });
      } else {
        this.plugin.settings.customReagents.forEach((reagent, index) => {
          const reagentEl = reagentContainer.createEl("div", { cls: "buffer-calc-reagent-item" });
          const infoEl = reagentEl.createEl("div", { cls: "buffer-calc-reagent-info" });
          infoEl.createEl("strong", { text: reagent.name });
          infoEl.createEl("span", { text: ` (MW: ${reagent.molecularWeight} g/mol)` });
          const actionsEl = reagentEl.createEl("div", { cls: "buffer-calc-reagent-actions" });
          const editBtn = actionsEl.createEl("button", { text: "Edit", cls: "mod-cta" });
          editBtn.addEventListener("click", () => {
            this.openReagentEditor(reagent, index, updateReagentList);
          });
          const deleteBtn = actionsEl.createEl("button", { text: "Delete", cls: "mod-destructive" });
          deleteBtn.addEventListener("click", async () => {
            this.plugin.settings.customReagents.splice(index, 1);
            await this.plugin.saveSettings();
            updateReagentList();
            new import_obsidian.Notice("Reagent deleted");
          });
        });
      }
    };
    updateReagentList();
    new import_obsidian.Setting(containerEl).setName("Add custom reagent").setDesc("Add a new reagent to your personal database").addButton((button) => {
      button.setButtonText("Add Reagent").setClass("mod-cta").onClick(() => {
        this.openReagentEditor(null, -1, updateReagentList);
      });
    });
  }
  addDataManagement() {
    const { containerEl } = this;
    containerEl.createEl("h2", { text: "Data Management" });
    new import_obsidian.Setting(containerEl).setName("Export settings").setDesc("Export your plugin settings to a file").addButton((button) => {
      button.setButtonText("Export").onClick(() => {
        this.exportSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Import settings").setDesc("Import plugin settings from a file").addButton((button) => {
      button.setButtonText("Import").onClick(() => {
        this.importSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Reset to defaults").setDesc("Reset all settings to their default values").addButton((button) => {
      button.setButtonText("Reset").setClass("mod-destructive").onClick(async () => {
        if (confirm("Are you sure you want to reset all settings to defaults? This cannot be undone.")) {
          this.plugin.settings = { ...this.plugin.settings, ...(init_types(), __toCommonJS(types_exports)).DEFAULT_SETTINGS };
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice("Settings reset to defaults");
        }
      });
    });
  }
  openReagentEditor(reagent, index, callback) {
    const modal = new ReagentEditorModal(
      this.app,
      reagent,
      async (updatedReagent) => {
        if (index >= 0) {
          this.plugin.settings.customReagents[index] = updatedReagent;
        } else {
          this.plugin.settings.customReagents.push(updatedReagent);
        }
        await this.plugin.saveSettings();
        callback();
        new import_obsidian.Notice(`Reagent ${reagent ? "updated" : "added"} successfully`);
      }
    );
    modal.open();
  }
  async exportSettings() {
    try {
      const data = JSON.stringify(this.plugin.settings, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "buffer-calc-settings.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      new import_obsidian.Notice("Settings exported successfully");
    } catch (error) {
      new import_obsidian.Notice("Failed to export settings");
      console.error("Export error:", error);
    }
  }
  async importSettings() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file)
        return;
      const reader = new FileReader();
      reader.onload = async (e2) => {
        try {
          const imported = JSON.parse(e2.target.result);
          this.plugin.settings = { ...this.plugin.settings, ...imported };
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice("Settings imported successfully");
        } catch (error) {
          new import_obsidian.Notice("Invalid settings file");
          console.error("Import error:", error);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }
};
var ReagentEditorModal = class extends import_obsidian.Modal {
  constructor(app, reagent, onSave) {
    super(app);
    this.reagent = reagent;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.reagent ? "Edit Reagent" : "Add New Reagent" });
    new import_obsidian.Setting(contentEl).setName("Reagent name").setDesc("Common name of the reagent").addText((text) => {
      var _a;
      this.nameInput = text;
      text.setValue(((_a = this.reagent) == null ? void 0 : _a.name) || "").setPlaceholder("e.g., Tris-HCl");
    });
    new import_obsidian.Setting(contentEl).setName("Molecular weight").setDesc("Molecular weight in g/mol").addText((text) => {
      var _a, _b;
      this.mwInput = text;
      text.setValue(((_b = (_a = this.reagent) == null ? void 0 : _a.molecularWeight) == null ? void 0 : _b.toString()) || "").setPlaceholder("e.g., 157.6");
    });
    new import_obsidian.Setting(contentEl).setName("CAS number").setDesc("CAS registry number (optional)").addText((text) => {
      var _a;
      this.casInput = text;
      text.setValue(((_a = this.reagent) == null ? void 0 : _a.cas) || "").setPlaceholder("e.g., 77-86-1");
    });
    new import_obsidian.Setting(contentEl).setName("Category").setDesc("Reagent category (optional)").addText((text) => {
      var _a;
      this.categoryInput = text;
      text.setValue(((_a = this.reagent) == null ? void 0 : _a.category) || "").setPlaceholder("e.g., Buffer, Salt, Enzyme");
    });
    const buttonContainer = contentEl.createEl("div", { cls: "buffer-calc-modal-buttons" });
    const saveButton = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveButton.addEventListener("click", () => this.save());
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
  }
  save() {
    const name = this.nameInput.getValue().trim();
    const mw = parseFloat(this.mwInput.getValue());
    if (!name) {
      new import_obsidian.Notice("Please enter a reagent name");
      return;
    }
    if (isNaN(mw) || mw <= 0) {
      new import_obsidian.Notice("Please enter a valid molecular weight");
      return;
    }
    const reagent = {
      name,
      molecularWeight: mw,
      cas: this.casInput.getValue().trim() || void 0,
      category: this.categoryInput.getValue().trim() || void 0
    };
    this.onSave(reagent);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/calculations/engine.ts
init_types();
var CalculationEngine = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  calculateBuffer(data) {
    const errors = [];
    const warnings = [];
    const calculationSteps = [];
    const components = [];
    this.validateBufferData(data, errors);
    if (errors.length > 0) {
      return {
        recipe: this.createBufferRecipe(data),
        components: [],
        solventVolume: 0,
        warnings,
        errors,
        calculationSteps
      };
    }
    const totalVolumeL = this.convertVolume(
      data.totalVolume,
      data.volumeUnit || this.settings.defaultVolumeUnit,
      "L" /* LITER */
    );
    let step = 1;
    let totalComponentVolume = 0;
    const componentList = Array.isArray(data.components) ? data.components : [];
    componentList.forEach((component, index) => {
      try {
        const calculatedComponent = this.calculateComponent(
          component,
          totalVolumeL,
          index,
          warnings,
          calculationSteps,
          step
        );
        components.push(calculatedComponent);
        totalComponentVolume += calculatedComponent.volumeNeeded;
        step += 2;
      } catch (error) {
        errors.push({
          type: "calculation_error" /* CALCULATION_ERROR */,
          message: `Error calculating component ${component.name}: ${error.message}`,
          componentIndex: index
        });
      }
    });
    const solventVolumeL = Math.max(0, totalVolumeL - totalComponentVolume);
    const solventVolume = this.convertVolume(solventVolumeL, "L" /* LITER */, data.volumeUnit || this.settings.defaultVolumeUnit);
    console.log("Solvent calculation debug:");
    console.log("- Total volume (L):", totalVolumeL);
    console.log("- Total component volume (L):", totalComponentVolume);
    console.log("- Solvent volume (L):", solventVolumeL);
    console.log("- Solvent volume (display unit):", solventVolume);
    if (this.settings.showCalculationSteps) {
      calculationSteps.push({
        step,
        description: `Calculate solvent volume`,
        formula: `Solvent volume = Total volume - Sum of component volumes`,
        result: solventVolume,
        unit: data.volumeUnit || this.settings.defaultVolumeUnit
      });
    }
    if (solventVolumeL < 0) {
      warnings.push({
        type: "volume_overflow" /* VOLUME_OVERFLOW */,
        message: "Component volumes exceed total volume. Consider increasing total volume.",
        severity: "high"
      });
    }
    if (solventVolumeL < totalVolumeL * 0.1) {
      warnings.push({
        type: "small_volume" /* SMALL_VOLUME */,
        message: "Solvent volume is very small. Consider reducing component concentrations.",
        severity: "medium"
      });
    }
    const finalResult = {
      recipe: this.createBufferRecipe(data),
      components,
      solventVolume: Math.max(0, solventVolume),
      warnings,
      errors,
      calculationSteps: this.settings.showCalculationSteps ? calculationSteps : void 0
    };
    console.log("Final calculation result:", finalResult);
    return finalResult;
  }
  calculateComponent(component, totalVolumeL, index, warnings, calculationSteps, step) {
    const stockConcM = this.convertConcentration(
      component.stockConc,
      component.stockUnit,
      "M" /* MOLAR */
    );
    const finalConcM = this.convertConcentration(
      component.finalConc,
      component.finalUnit,
      "M" /* MOLAR */
    );
    if (finalConcM > stockConcM) {
      throw new Error(`Final concentration (${component.finalConc} ${component.finalUnit}) cannot be higher than stock concentration (${component.stockConc} ${component.stockUnit})`);
    }
    const requiredVolumeL = finalConcM * totalVolumeL / stockConcM;
    const requiredVolume = this.convertVolume(
      requiredVolumeL,
      "L" /* LITER */,
      this.settings.defaultVolumeUnit
    );
    if (this.settings.showCalculationSteps) {
      calculationSteps.push({
        step,
        description: `Calculate ${component.name} volume`,
        formula: `V\u2081 = (C\u2082 \xD7 V\u2082) / C\u2081 = (${finalConcM} M \xD7 ${totalVolumeL} L) / ${stockConcM} M`,
        result: requiredVolumeL,
        unit: "L" /* LITER */
      });
      calculationSteps.push({
        step: step + 1,
        description: `Convert to ${this.settings.defaultVolumeUnit}`,
        formula: `${requiredVolumeL} L \xD7 ${VOLUME_CONVERSION_FACTORS[this.settings.defaultVolumeUnit]}`,
        result: requiredVolume,
        unit: this.settings.defaultVolumeUnit
      });
    }
    this.generateComponentWarnings(component, requiredVolume, stockConcM, finalConcM, warnings, index);
    const percentOfTotal = requiredVolumeL / totalVolumeL * 100;
    return {
      reagent: {
        name: component.name,
        molecularWeight: 0
        // Will be filled from database
      },
      stockConcentration: component.stockConc,
      stockConcentrationUnit: component.stockUnit,
      finalConcentration: component.finalConc,
      finalConcentrationUnit: component.finalUnit,
      volumeNeeded: requiredVolumeL,
      // Use liters for calculation consistency
      volumeUnit: this.settings.defaultVolumeUnit,
      optimizedVolumeDisplay: this.optimizeVolumeDisplay(requiredVolume, this.settings.defaultVolumeUnit),
      percentOfTotal: Math.round(percentOfTotal * 100) / 100,
      lotNumber: component.lotNumber
    };
  }
  calculateStock(data) {
    const errors = [];
    const warnings = [];
    const calculationSteps = [];
    if (!data.molecularWeight || data.molecularWeight <= 0) {
      errors.push({
        type: "invalid_molecular_weight" /* INVALID_MOLECULAR_WEIGHT */,
        message: "Valid molecular weight is required for stock solution calculation",
        field: "molecularWeight"
      });
    }
    if (errors.length > 0) {
      return {
        recipe: {
          id: "",
          name: `${data.reagent} Stock Solution`,
          totalVolume: data.volume,
          totalVolumeUnit: data.volumeUnit,
          components: [],
          createdAt: new Date(),
          updatedAt: new Date()
        },
        components: [],
        solventVolume: 0,
        warnings,
        errors,
        calculationSteps
      };
    }
    const volumeL = this.convertVolume(data.volume, data.volumeUnit, "L" /* LITER */);
    const concentrationM = this.convertConcentration(
      data.targetConcentration,
      data.concentrationUnit,
      "M" /* MOLAR */
    );
    let massG = concentrationM * volumeL * data.molecularWeight;
    if (data.purity && data.purity > 0 && data.purity < 100) {
      massG = massG / (data.purity / 100);
    }
    const { mass: optimizedMass, unit: massUnit } = this.optimizeMassDisplay(massG);
    if (this.settings.showCalculationSteps) {
      calculationSteps.push({
        step: 1,
        description: "Calculate required mass",
        formula: `Mass = Concentration \xD7 Volume \xD7 Molecular Weight = ${concentrationM} mol/L \xD7 ${volumeL} L \xD7 ${data.molecularWeight} g/mol`,
        result: massG,
        unit: "g" /* GRAM */
      });
      if (data.purity && data.purity !== 100) {
        calculationSteps.push({
          step: 2,
          description: "Adjust for purity",
          formula: `Adjusted mass = ${massG} g / (${data.purity}% / 100%)`,
          result: massG / (data.purity / 100),
          unit: "g" /* GRAM */
        });
      }
    }
    if (massG < 1e-3) {
      warnings.push({
        type: "small_volume" /* SMALL_VOLUME */,
        message: "Very small mass required. Consider making a more dilute stock solution.",
        severity: "medium"
      });
    }
    if (massG > 10) {
      warnings.push({
        type: "large_volume" /* LARGE_VOLUME */,
        message: "Large mass required. Consider making a smaller volume or more concentrated stock.",
        severity: "low"
      });
    }
    const component = {
      reagent: {
        name: data.reagent,
        molecularWeight: data.molecularWeight
      },
      stockConcentration: data.targetConcentration,
      stockConcentrationUnit: data.concentrationUnit,
      finalConcentration: data.targetConcentration,
      finalConcentrationUnit: data.concentrationUnit,
      volumeNeeded: optimizedMass,
      volumeUnit: massUnit,
      optimizedVolumeDisplay: `${this.formatNumber(optimizedMass)} ${massUnit}`,
      percentOfTotal: 100,
      massEquivalent: optimizedMass,
      massUnit
    };
    return {
      recipe: {
        id: "",
        name: `${data.reagent} Stock Solution`,
        totalVolume: data.volume,
        totalVolumeUnit: data.volumeUnit,
        components: [component],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      components: [component],
      solventVolume: data.volume,
      // The entire volume is solvent + solute
      warnings,
      errors,
      calculationSteps: this.settings.showCalculationSteps ? calculationSteps : void 0
    };
  }
  validateBufferData(data, errors) {
    if (!data.totalVolume || data.totalVolume <= 0) {
      errors.push({
        type: "negative_value" /* NEGATIVE_VALUE */,
        message: "Total volume must be greater than 0",
        field: "totalVolume"
      });
    }
    if (!Array.isArray(data.components) || data.components.length === 0) {
      errors.push({
        type: "missing_required_field" /* MISSING_REQUIRED_FIELD */,
        message: "At least one component is required",
        field: "components"
      });
      return;
    }
    const validationComponents = Array.isArray(data.components) ? data.components : [];
    validationComponents.forEach((component, index) => {
      if (!component.name || component.name.trim() === "") {
        errors.push({
          type: "missing_required_field" /* MISSING_REQUIRED_FIELD */,
          message: "Component name is required",
          componentIndex: index,
          field: "name"
        });
      }
      if (!component.stockConc || component.stockConc <= 0) {
        errors.push({
          type: "negative_value" /* NEGATIVE_VALUE */,
          message: "Stock concentration must be greater than 0",
          componentIndex: index,
          field: "stockConc"
        });
      }
      if (!component.finalConc || component.finalConc <= 0) {
        errors.push({
          type: "negative_value" /* NEGATIVE_VALUE */,
          message: "Final concentration must be greater than 0",
          componentIndex: index,
          field: "finalConc"
        });
      }
    });
  }
  generateComponentWarnings(component, requiredVolume, stockConcM, finalConcM, warnings, index) {
    if (requiredVolume < 0.1) {
      warnings.push({
        type: "small_volume" /* SMALL_VOLUME */,
        message: `Very small volume required for ${component.name} (${this.formatNumber(requiredVolume)} ${this.settings.defaultVolumeUnit}). Consider using a more dilute stock.`,
        componentIndex: index,
        severity: "medium"
      });
    }
    const dilutionFactor = stockConcM / finalConcM;
    if (dilutionFactor > 1e3) {
      warnings.push({
        type: "unusual_dilution_factor" /* UNUSUAL_DILUTION_FACTOR */,
        message: `Very high dilution factor for ${component.name} (${Math.round(dilutionFactor)}\xD7). Consider using a more dilute stock.`,
        componentIndex: index,
        severity: "low"
      });
    }
  }
  convertVolume(value, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return value;
    const inLiters = value / VOLUME_CONVERSION_FACTORS[fromUnit];
    return inLiters * VOLUME_CONVERSION_FACTORS[toUnit];
  }
  convertConcentration(value, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return value;
    if (["M" /* MOLAR */, "mM" /* MILLIMOLAR */, "\xB5M" /* MICROMOLAR */, "nM" /* NANOMOLAR */].includes(fromUnit) && ["M" /* MOLAR */, "mM" /* MILLIMOLAR */, "\xB5M" /* MICROMOLAR */, "nM" /* NANOMOLAR */].includes(toUnit)) {
      const inMolar = value / CONCENTRATION_CONVERSION_FACTORS[fromUnit];
      return inMolar * CONCENTRATION_CONVERSION_FACTORS[toUnit];
    }
    return value;
  }
  optimizeVolumeDisplay(volume, unit) {
    const conversions = [
      { unit: "L" /* LITER */, threshold: 1 },
      { unit: "mL" /* MILLILITER */, threshold: 1 },
      { unit: "\xB5L" /* MICROLITER */, threshold: 1 },
      { unit: "nL" /* NANOLITER */, threshold: 1 }
    ];
    for (const conversion of conversions) {
      const convertedValue = this.convertVolume(volume, unit, conversion.unit);
      if (convertedValue >= conversion.threshold) {
        return `${this.formatNumber(convertedValue)} ${conversion.unit}`;
      }
    }
    return `${this.formatNumber(volume)} ${unit}`;
  }
  optimizeMassDisplay(massG) {
    if (massG >= 1) {
      return { mass: massG, unit: "g" /* GRAM */ };
    } else if (massG >= 1e-3) {
      return { mass: massG * 1e3, unit: "mg" /* MILLIGRAM */ };
    } else if (massG >= 1e-6) {
      return { mass: massG * 1e6, unit: "\xB5g" /* MICROGRAM */ };
    } else {
      return { mass: massG * 1e9, unit: "ng" /* NANOGRAM */ };
    }
  }
  formatNumber(value) {
    return Number(value.toFixed(this.settings.decimalPlaces)).toString();
  }
  createBufferRecipe(data) {
    return {
      id: "",
      name: data.name || "Untitled Buffer",
      totalVolume: data.totalVolume,
      totalVolumeUnit: data.volumeUnit || this.settings.defaultVolumeUnit,
      components: [],
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
};

// src/data/reagents.ts
var ReagentDatabase = class {
  constructor() {
    this.builtInReagents = [];
    this.userReagents = [];
  }
  async initialize() {
    this.builtInReagents = this.getBuiltInReagents();
  }
  /**
   * Search for reagents by name (fuzzy matching)
   */
  searchReagents(query, includeCustom = true) {
    const allReagents = includeCustom ? [...this.builtInReagents, ...this.userReagents] : this.builtInReagents;
    if (!query.trim()) {
      return allReagents.slice(0, 20);
    }
    const queryLower = query.toLowerCase();
    return allReagents.filter(
      (reagent) => {
        var _a, _b;
        return reagent.name.toLowerCase().includes(queryLower) || ((_a = reagent.cas) == null ? void 0 : _a.includes(query)) || ((_b = reagent.category) == null ? void 0 : _b.toLowerCase().includes(queryLower));
      }
    ).sort((a, b) => {
      const aExact = a.name.toLowerCase() === queryLower;
      const bExact = b.name.toLowerCase() === queryLower;
      if (aExact && !bExact)
        return -1;
      if (!aExact && bExact)
        return 1;
      const aStarts = a.name.toLowerCase().startsWith(queryLower);
      const bStarts = b.name.toLowerCase().startsWith(queryLower);
      if (aStarts && !bStarts)
        return -1;
      if (!aStarts && bStarts)
        return 1;
      return a.name.localeCompare(b.name);
    }).slice(0, 20);
  }
  /**
   * Get reagent by exact name match
   */
  getReagentByName(name) {
    const allReagents = [...this.builtInReagents, ...this.userReagents];
    return allReagents.find(
      (reagent) => reagent.name.toLowerCase() === name.toLowerCase()
    ) || null;
  }
  /**
   * Add user custom reagent
   */
  addUserReagent(reagent) {
    this.userReagents.push(reagent);
  }
  /**
   * Update user custom reagent
   */
  updateUserReagent(index, reagent) {
    if (index >= 0 && index < this.userReagents.length) {
      this.userReagents[index] = reagent;
    }
  }
  /**
   * Remove user custom reagent
   */
  removeUserReagent(index) {
    if (index >= 0 && index < this.userReagents.length) {
      this.userReagents.splice(index, 1);
    }
  }
  /**
   * Get all user reagents
   */
  getUserReagents() {
    return [...this.userReagents];
  }
  /**
   * Set user reagents (for loading from settings)
   */
  setUserReagents(reagents) {
    this.userReagents = reagents;
  }
  /**
   * Get reagents by category
   */
  getReagentsByCategory(category) {
    const allReagents = [...this.builtInReagents, ...this.userReagents];
    return allReagents.filter(
      (reagent) => {
        var _a;
        return ((_a = reagent.category) == null ? void 0 : _a.toLowerCase()) === category.toLowerCase();
      }
    );
  }
  /**
   * Get all available categories
   */
  getCategories() {
    const allReagents = [...this.builtInReagents, ...this.userReagents];
    const categories = /* @__PURE__ */ new Set();
    allReagents.forEach((reagent) => {
      if (reagent.category) {
        categories.add(reagent.category);
      }
    });
    return Array.from(categories).sort();
  }
  /**
   * Generate external links for a reagent
   */
  getExternalLinks(reagent) {
    const links = [];
    if (reagent.pubchemId) {
      links.push({
        name: "PubChem",
        url: `https://pubchem.ncbi.nlm.nih.gov/compound/${reagent.pubchemId}`
      });
    } else if (reagent.name) {
      const searchName = encodeURIComponent(reagent.name);
      links.push({
        name: "PubChem Search",
        url: `https://pubchem.ncbi.nlm.nih.gov/#query=${searchName}`
      });
    }
    if (reagent.cas) {
      links.push({
        name: "Sigma-Aldrich",
        url: `https://www.sigmaaldrich.com/US/en/search/${reagent.cas}?focus=products&page=1&perpage=30&sort=relevance&term=${reagent.cas}&type=cas_number`
      });
    }
    if (reagent.name) {
      const searchName = encodeURIComponent(reagent.name);
      links.push({
        name: "Thermo Fisher",
        url: `https://www.thermofisher.com/search/results?query=${searchName}&searchLocation=US&focusarea=Search%20All`
      });
    }
    return links;
  }
  getBuiltInReagents() {
    return [
      // Buffers
      {
        name: "Tris",
        molecularWeight: 121.14,
        cas: "77-86-1",
        pubchemId: "6503",
        category: "Buffer",
        hazards: ["Irritant"]
      },
      {
        name: "Tris-HCl",
        molecularWeight: 157.6,
        cas: "1185-53-1",
        category: "Buffer",
        hazards: ["Irritant"]
      },
      {
        name: "HEPES",
        molecularWeight: 238.31,
        cas: "7365-45-9",
        pubchemId: "23831",
        category: "Buffer",
        hazards: ["Irritant"]
      },
      {
        name: "PIPES",
        molecularWeight: 302.37,
        cas: "5625-37-6",
        pubchemId: "79723",
        category: "Buffer",
        hazards: ["Irritant"]
      },
      {
        name: "MOPS",
        molecularWeight: 209.26,
        cas: "1132-61-2",
        pubchemId: "70678",
        category: "Buffer",
        hazards: ["Irritant"]
      },
      {
        name: "Bis-Tris",
        molecularWeight: 209.24,
        cas: "6976-37-0",
        pubchemId: "160556",
        category: "Buffer"
      },
      {
        name: "Tricine",
        molecularWeight: 179.17,
        cas: "5704-04-1",
        pubchemId: "92958",
        category: "Buffer"
      },
      {
        name: "CAPS",
        molecularWeight: 221.31,
        cas: "1135-40-6",
        pubchemId: "71578",
        category: "Buffer"
      },
      // Salts
      {
        name: "NaCl",
        molecularWeight: 58.44,
        cas: "7647-14-5",
        pubchemId: "5234",
        category: "Salt"
      },
      {
        name: "KCl",
        molecularWeight: 74.55,
        cas: "7447-40-7",
        pubchemId: "4873",
        category: "Salt"
      },
      {
        name: "MgCl2",
        molecularWeight: 95.21,
        cas: "7786-30-3",
        pubchemId: "5360315",
        category: "Salt"
      },
      {
        name: "MgCl2\xB76H2O",
        molecularWeight: 203.3,
        cas: "7791-18-6",
        pubchemId: "24584",
        category: "Salt"
      },
      {
        name: "CaCl2",
        molecularWeight: 110.98,
        cas: "10043-52-4",
        pubchemId: "5284359",
        category: "Salt"
      },
      {
        name: "CaCl2\xB72H2O",
        molecularWeight: 147.01,
        cas: "10035-04-8",
        pubchemId: "24844",
        category: "Salt"
      },
      {
        name: "Na2HPO4",
        molecularWeight: 141.96,
        cas: "7558-79-4",
        pubchemId: "24203",
        category: "Salt"
      },
      {
        name: "NaH2PO4",
        molecularWeight: 119.98,
        cas: "7558-80-7",
        pubchemId: "23672064",
        category: "Salt"
      },
      {
        name: "K2HPO4",
        molecularWeight: 174.18,
        cas: "7758-11-4",
        pubchemId: "24450",
        category: "Salt"
      },
      {
        name: "KH2PO4",
        molecularWeight: 136.09,
        cas: "7778-77-0",
        pubchemId: "516951",
        category: "Salt"
      },
      // Detergents
      {
        name: "Triton X-100",
        molecularWeight: 647,
        cas: "9002-93-1",
        category: "Detergent",
        hazards: ["Toxic", "Environmental hazard"]
      },
      {
        name: "Tween 20",
        molecularWeight: 1227.54,
        cas: "9005-64-5",
        pubchemId: "16129878",
        category: "Detergent"
      },
      {
        name: "SDS",
        molecularWeight: 288.38,
        cas: "151-21-3",
        pubchemId: "3423265",
        category: "Detergent",
        hazards: ["Irritant", "Harmful"]
      },
      {
        name: "NP-40",
        molecularWeight: 603,
        cas: "9016-45-9",
        category: "Detergent",
        hazards: ["Harmful"]
      },
      // Reducing agents
      {
        name: "DTT",
        molecularWeight: 154.25,
        cas: "3483-12-3",
        pubchemId: "446094",
        category: "Reducing Agent"
      },
      {
        name: "TCEP",
        molecularWeight: 286.65,
        cas: "51805-45-9",
        pubchemId: "115109",
        category: "Reducing Agent"
      },
      {
        name: "\u03B2-Mercaptoethanol",
        molecularWeight: 78.13,
        cas: "60-24-2",
        pubchemId: "1567",
        category: "Reducing Agent",
        hazards: ["Toxic", "Flammable"]
      },
      // Protease inhibitors
      {
        name: "PMSF",
        molecularWeight: 174.19,
        cas: "329-98-6",
        pubchemId: "4784",
        category: "Protease Inhibitor",
        hazards: ["Toxic", "Flammable"]
      },
      {
        name: "Benzamidine HCl",
        molecularWeight: 156.61,
        cas: "1670-14-0",
        pubchemId: "12699",
        category: "Protease Inhibitor"
      },
      {
        name: "EDTA",
        molecularWeight: 292.24,
        cas: "60-00-4",
        pubchemId: "6049",
        category: "Chelator"
      },
      {
        name: "EGTA",
        molecularWeight: 380.35,
        cas: "67-42-5",
        pubchemId: "6207",
        category: "Chelator"
      },
      // Common organics
      {
        name: "Glycerol",
        molecularWeight: 92.09,
        cas: "56-81-5",
        pubchemId: "753",
        category: "Organic"
      },
      {
        name: "Sucrose",
        molecularWeight: 342.3,
        cas: "57-50-1",
        pubchemId: "5988",
        category: "Organic"
      },
      {
        name: "Glucose",
        molecularWeight: 180.16,
        cas: "50-99-7",
        pubchemId: "5793",
        category: "Organic"
      },
      {
        name: "Imidazole",
        molecularWeight: 68.08,
        cas: "288-32-4",
        pubchemId: "795",
        category: "Organic"
      },
      {
        name: "Glycine",
        molecularWeight: 75.07,
        cas: "56-40-6",
        pubchemId: "750",
        category: "Amino Acid"
      },
      {
        name: "Urea",
        molecularWeight: 60.06,
        cas: "57-13-6",
        pubchemId: "1176",
        category: "Chaotrope",
        hazards: ["Irritant"]
      },
      {
        name: "Guanidine HCl",
        molecularWeight: 95.53,
        cas: "50-01-1",
        pubchemId: "3547",
        category: "Chaotrope",
        hazards: ["Harmful"]
      }
    ];
  }
};

// src/ui/buffer-calc-ui.ts
var import_obsidian2 = require("obsidian");
init_types();

// src/utils/conversions.ts
init_types();
var ConversionUtils = class {
  /**
   * Convert volume between different units
   */
  static convertVolume(value, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return value;
    const inLiters = value / VOLUME_CONVERSION_FACTORS[fromUnit];
    return inLiters * VOLUME_CONVERSION_FACTORS[toUnit];
  }
  /**
   * Convert mass between different units
   */
  static convertMass(value, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return value;
    const inGrams = value / MASS_CONVERSION_FACTORS[fromUnit];
    return inGrams * MASS_CONVERSION_FACTORS[toUnit];
  }
  /**
   * Convert concentration between molar units (M, mM, ÂµM, nM)
   */
  static convertMolarConcentration(value, fromUnit, toUnit) {
    if (fromUnit === toUnit)
      return value;
    const molarUnits = [
      "M" /* MOLAR */,
      "mM" /* MILLIMOLAR */,
      "\xB5M" /* MICROMOLAR */,
      "nM" /* NANOMOLAR */
    ];
    if (!molarUnits.includes(fromUnit) || !molarUnits.includes(toUnit)) {
      throw new Error("Can only convert between molar concentration units (M, mM, \xB5M, nM)");
    }
    const inMolar = value / CONCENTRATION_CONVERSION_FACTORS[fromUnit];
    return inMolar * CONCENTRATION_CONVERSION_FACTORS[toUnit];
  }
  /**
   * Convert concentration to molarity (requires molecular weight for non-molar units)
   */
  static convertToMolarity(value, unit, molecularWeight) {
    const molarUnits = [
      "M" /* MOLAR */,
      "mM" /* MILLIMOLAR */,
      "\xB5M" /* MICROMOLAR */,
      "nM" /* NANOMOLAR */
    ];
    if (molarUnits.includes(unit)) {
      return this.convertMolarConcentration(value, unit, "M" /* MOLAR */);
    }
    if (!molecularWeight || molecularWeight <= 0) {
      throw new Error("Molecular weight is required to convert from mass-based concentrations to molarity");
    }
    switch (unit) {
      case "mg/mL" /* MG_ML */:
        return value / (molecularWeight * 1e3);
      case "\xB5g/mL" /* UG_ML */:
        return value / (molecularWeight * 1e6);
      case "%(w/v)" /* PERCENT_W_V */:
        return value * 1e4 / (molecularWeight * 1e3);
      default:
        throw new Error(`Conversion from ${unit} to molarity not implemented`);
    }
  }
  /**
   * Format number with appropriate decimal places
   */
  static formatNumber(value, decimalPlaces = 2) {
    return Number(value.toFixed(decimalPlaces)).toString();
  }
  /**
   * Get the most appropriate volume unit for display
   */
  static optimizeVolumeDisplay(volume, unit) {
    const conversions = [
      { unit: "L" /* LITER */, min: 1, max: Infinity },
      { unit: "mL" /* MILLILITER */, min: 1, max: 1e3 },
      { unit: "\xB5L" /* MICROLITER */, min: 1, max: 1e3 },
      { unit: "nL" /* NANOLITER */, min: 0, max: 1e3 }
    ];
    for (const conversion of conversions) {
      const convertedValue = this.convertVolume(volume, unit, conversion.unit);
      if (convertedValue >= conversion.min && convertedValue < conversion.max) {
        return { value: convertedValue, unit: conversion.unit };
      }
    }
    return { value: volume, unit };
  }
  /**
   * Get the most appropriate mass unit for display
   */
  static optimizeMassDisplay(mass, unit) {
    const conversions = [
      { unit: "g" /* GRAM */, min: 1, max: Infinity },
      { unit: "mg" /* MILLIGRAM */, min: 1, max: 1e3 },
      { unit: "\xB5g" /* MICROGRAM */, min: 1, max: 1e3 },
      { unit: "ng" /* NANOGRAM */, min: 0, max: 1e3 }
    ];
    for (const conversion of conversions) {
      const convertedValue = this.convertMass(mass, unit, conversion.unit);
      if (convertedValue >= conversion.min && convertedValue < conversion.max) {
        return { value: convertedValue, unit: conversion.unit };
      }
    }
    return { value: mass, unit };
  }
  /**
   * Calculate dilution factor
   */
  static calculateDilutionFactor(stockConc, finalConc) {
    if (finalConc <= 0) {
      throw new Error("Final concentration must be greater than 0");
    }
    return stockConc / finalConc;
  }
  /**
   * Validate that a concentration conversion is possible
   */
  static canConvertConcentration(fromUnit, toUnit) {
    const molarUnits = [
      "M" /* MOLAR */,
      "mM" /* MILLIMOLAR */,
      "\xB5M" /* MICROMOLAR */,
      "nM" /* NANOMOLAR */
    ];
    const massUnits = [
      "mg/mL" /* MG_ML */,
      "\xB5g/mL" /* UG_ML */
    ];
    const percentUnits = [
      "%(w/v)" /* PERCENT_W_V */,
      "%(w/w)" /* PERCENT_W_W */,
      "%(v/v)" /* PERCENT_V_V */
    ];
    if (molarUnits.includes(fromUnit) && molarUnits.includes(toUnit))
      return true;
    if (massUnits.includes(fromUnit) && massUnits.includes(toUnit))
      return true;
    if (percentUnits.includes(fromUnit) && percentUnits.includes(toUnit))
      return true;
    if (molarUnits.includes(fromUnit) && massUnits.includes(toUnit))
      return true;
    if (massUnits.includes(fromUnit) && molarUnits.includes(toUnit))
      return true;
    if (molarUnits.includes(fromUnit) && fromUnit === "%(w/v)" /* PERCENT_W_V */)
      return true;
    if (fromUnit === "%(w/v)" /* PERCENT_W_V */ && molarUnits.includes(toUnit))
      return true;
    return false;
  }
  /**
   * Get human-readable unit names
   */
  static getUnitDisplayName(unit) {
    const displayNames = {
      // Volume units
      ["L" /* LITER */]: "Liter",
      ["mL" /* MILLILITER */]: "Milliliter",
      ["\xB5L" /* MICROLITER */]: "Microliter",
      ["nL" /* NANOLITER */]: "Nanoliter",
      // Concentration units
      ["M" /* MOLAR */]: "Molar",
      ["mM" /* MILLIMOLAR */]: "Millimolar",
      ["\xB5M" /* MICROMOLAR */]: "Micromolar",
      ["nM" /* NANOMOLAR */]: "Nanomolar",
      ["%(w/v)" /* PERCENT_W_V */]: "Percent (w/v)",
      ["%(w/w)" /* PERCENT_W_W */]: "Percent (w/w)",
      ["%(v/v)" /* PERCENT_V_V */]: "Percent (v/v)",
      ["mg/mL" /* MG_ML */]: "mg/mL",
      ["\xB5g/mL" /* UG_ML */]: "\xB5g/mL",
      ["ppm" /* PPM */]: "Parts per million",
      ["ppb" /* PPB */]: "Parts per billion",
      // Mass units
      ["g" /* GRAM */]: "Gram",
      ["mg" /* MILLIGRAM */]: "Milligram",
      ["\xB5g" /* MICROGRAM */]: "Microgram",
      ["ng" /* NANOGRAM */]: "Nanogram"
    };
    return displayNames[unit] || unit;
  }
  /**
   * Validate numeric input
   */
  static validatePositiveNumber(value, fieldName) {
    const num = Number(value);
    if (isNaN(num) || num <= 0) {
      throw new Error(`${fieldName} must be a positive number`);
    }
    return num;
  }
  /**
   * Validate non-negative numeric input
   */
  static validateNonNegativeNumber(value, fieldName) {
    const num = Number(value);
    if (isNaN(num) || num < 0) {
      throw new Error(`${fieldName} must be a non-negative number`);
    }
    return num;
  }
};

// src/ui/buffer-calc-ui.ts
var BufferCalcUI = class {
  constructor(container, blockContent, calculationEngine, reagentDatabase, settings, context) {
    this.lastResult = null;
    this.container = container;
    this.blockContent = blockContent;
    this.calculationEngine = calculationEngine;
    this.reagentDatabase = reagentDatabase;
    this.settings = settings;
    this.context = context;
  }
  async render() {
    this.container.empty();
    this.container.addClass("buffer-calc-ui");
    switch (this.blockContent.type) {
      case "buffer":
        await this.renderBufferCalculator();
        break;
      case "stock":
        await this.renderStockCalculator();
        break;
      case "dilution":
        await this.renderDilutionCalculator();
        break;
      default:
        this.container.createEl("div", {
          text: `Unknown calculation type: ${this.blockContent.type}`,
          cls: "buffer-calc-error"
        });
    }
  }
  async renderBufferCalculator() {
    const data = this.blockContent.data;
    const header = this.container.createEl("div", { cls: "buffer-calc-header" });
    header.createEl("h3", { text: data.name || "Buffer Calculation", cls: "buffer-calc-title" });
    const controls = this.container.createEl("div", { cls: "buffer-calc-controls" });
    const volumeContainer = controls.createEl("div", { cls: "buffer-calc-volume-input" });
    volumeContainer.createEl("label", { text: "Total Volume:" });
    const volumeInput = volumeContainer.createEl("input", {
      type: "number",
      value: data.totalVolume.toString(),
      cls: "buffer-calc-input-number"
    });
    const volumeUnitSelect = volumeContainer.createEl("select", { cls: "buffer-calc-unit-select" });
    this.populateVolumeUnits(volumeUnitSelect, data.volumeUnit || this.settings.defaultVolumeUnit);
    volumeInput.addEventListener("input", () => this.updateCalculation());
    volumeUnitSelect.addEventListener("change", () => this.updateCalculation());
    const componentsContainer = this.container.createEl("div", { cls: "buffer-calc-components" });
    componentsContainer.createEl("h4", { text: "Components" });
    const componentsList = componentsContainer.createEl("div", { cls: "buffer-calc-components-list" });
    const components = Array.isArray(data.components) ? data.components : [];
    components.forEach((component, index) => {
      this.renderComponent(componentsList, component, index);
    });
    const addButton = componentsContainer.createEl("button", {
      text: "+ Add Component",
      cls: "buffer-calc-add-button mod-cta"
    });
    addButton.addEventListener("click", () => {
      const newComponent = {
        name: "",
        stockConc: 100,
        stockUnit: this.settings.defaultConcentrationUnit,
        finalConc: 10,
        finalUnit: this.settings.defaultConcentrationUnit
      };
      if (!Array.isArray(data.components)) {
        data.components = [];
      }
      data.components.push(newComponent);
      this.renderComponent(componentsList, newComponent, data.components.length - 1);
      this.updateCalculation();
    });
    const resultsContainer = this.container.createEl("div", { cls: "buffer-calc-results" });
    this.updateCalculation();
  }
  renderComponent(container, component, index) {
    const componentEl = container.createEl("div", { cls: "buffer-calc-component" });
    const componentHeader = componentEl.createEl("div", { cls: "buffer-calc-component-header" });
    componentHeader.createEl("span", { text: `Component ${index + 1}` });
    const deleteButton = componentHeader.createEl("button", {
      text: "\xD7",
      cls: "buffer-calc-delete-button"
    });
    deleteButton.addEventListener("click", () => {
      const data = this.blockContent.data;
      if (Array.isArray(data.components)) {
        data.components.splice(index, 1);
      }
      this.render();
    });
    const nameContainer = componentEl.createEl("div", { cls: "buffer-calc-input-group" });
    nameContainer.createEl("label", { text: "Reagent:" });
    const nameInput = nameContainer.createEl("input", {
      type: "text",
      value: component.name,
      placeholder: "Enter reagent name...",
      cls: "buffer-calc-reagent-input"
    });
    const suggestionsContainer = nameContainer.createEl("div", {
      cls: "buffer-calc-suggestions"
    });
    suggestionsContainer.style.display = "none";
    this.setupReagentAutocomplete(nameInput, suggestionsContainer, (reagent) => {
      component.name = reagent.name;
      nameInput.value = reagent.name;
      this.updateCalculation();
    });
    nameInput.addEventListener("input", () => {
      component.name = nameInput.value;
      this.updateCalculation();
    });
    const stockContainer = componentEl.createEl("div", { cls: "buffer-calc-input-group" });
    stockContainer.createEl("label", { text: "Stock Concentration:" });
    const stockInput = stockContainer.createEl("input", {
      type: "number",
      value: component.stockConc.toString(),
      cls: "buffer-calc-input-number"
    });
    const stockUnitSelect = stockContainer.createEl("select", { cls: "buffer-calc-unit-select" });
    this.populateConcentrationUnits(stockUnitSelect, component.stockUnit);
    stockInput.addEventListener("input", () => {
      component.stockConc = parseFloat(stockInput.value) || 0;
      this.updateCalculation();
    });
    stockUnitSelect.addEventListener("change", () => {
      component.stockUnit = stockUnitSelect.value;
      this.updateCalculation();
    });
    const finalContainer = componentEl.createEl("div", { cls: "buffer-calc-input-group" });
    finalContainer.createEl("label", { text: "Final Concentration:" });
    const finalInput = finalContainer.createEl("input", {
      type: "number",
      value: component.finalConc.toString(),
      cls: "buffer-calc-input-number"
    });
    const finalUnitSelect = finalContainer.createEl("select", { cls: "buffer-calc-unit-select" });
    this.populateConcentrationUnits(finalUnitSelect, component.finalUnit);
    finalInput.addEventListener("input", () => {
      component.finalConc = parseFloat(finalInput.value) || 0;
      this.updateCalculation();
    });
    finalUnitSelect.addEventListener("change", () => {
      component.finalUnit = finalUnitSelect.value;
      this.updateCalculation();
    });
    const lotContainer = componentEl.createEl("div", { cls: "buffer-calc-input-group" });
    lotContainer.createEl("label", { text: "Lot # (optional):" });
    const lotInput = lotContainer.createEl("input", {
      type: "text",
      value: component.lotNumber || "",
      placeholder: "e.g., ABC123",
      cls: "buffer-calc-lot-input"
    });
    lotInput.addEventListener("input", () => {
      component.lotNumber = lotInput.value || void 0;
    });
  }
  setupReagentAutocomplete(input, container, onSelect) {
    let debounceTimer;
    input.addEventListener("input", () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const query = input.value.trim();
        if (query.length < 2) {
          container.style.display = "none";
          return;
        }
        const suggestions = this.reagentDatabase.searchReagents(query);
        if (suggestions.length === 0) {
          container.style.display = "none";
          return;
        }
        container.empty();
        container.style.display = "block";
        suggestions.slice(0, 10).forEach((reagent) => {
          const suggestionEl = container.createEl("div", {
            cls: "buffer-calc-suggestion-item",
            text: `${reagent.name} (MW: ${reagent.molecularWeight})`
          });
          suggestionEl.addEventListener("click", () => {
            onSelect(reagent);
            container.style.display = "none";
          });
        });
      }, 300);
    });
    document.addEventListener("click", (e) => {
      if (!container.contains(e.target) && !input.contains(e.target)) {
        container.style.display = "none";
      }
    });
  }
  populateVolumeUnits(select, selectedUnit) {
    const units = [
      { value: "L" /* LITER */, label: "L" },
      { value: "mL" /* MILLILITER */, label: "mL" },
      { value: "\xB5L" /* MICROLITER */, label: "\xB5L" },
      { value: "nL" /* NANOLITER */, label: "nL" }
    ];
    units.forEach((unit) => {
      const option = select.createEl("option", {
        value: unit.value,
        text: unit.label
      });
      if (unit.value === selectedUnit) {
        option.selected = true;
      }
    });
  }
  populateConcentrationUnits(select, selectedUnit) {
    const units = [
      { value: "M" /* MOLAR */, label: "M" },
      { value: "mM" /* MILLIMOLAR */, label: "mM" },
      { value: "\xB5M" /* MICROMOLAR */, label: "\xB5M" },
      { value: "nM" /* NANOMOLAR */, label: "nM" },
      { value: "%(w/v)" /* PERCENT_W_V */, label: "% (w/v)" },
      { value: "mg/mL" /* MG_ML */, label: "mg/mL" },
      { value: "\xB5g/mL" /* UG_ML */, label: "\xB5g/mL" }
    ];
    units.forEach((unit) => {
      const option = select.createEl("option", {
        value: unit.value,
        text: unit.label
      });
      if (unit.value === selectedUnit) {
        option.selected = true;
      }
    });
  }
  async updateCalculation() {
    const data = this.blockContent.data;
    const volumeInput = this.container.querySelector(".buffer-calc-input-number");
    const volumeUnitSelect = this.container.querySelector(".buffer-calc-unit-select");
    if (volumeInput && volumeUnitSelect) {
      data.totalVolume = parseFloat(volumeInput.value) || 0;
      data.volumeUnit = volumeUnitSelect.value;
    }
    try {
      const result = this.calculationEngine.calculateBuffer(data);
      this.lastResult = result;
      this.renderResults(result);
    } catch (error) {
      console.error("Calculation error:", error);
      this.renderError(error.message);
    }
  }
  renderResults(result) {
    let resultsContainer = this.container.querySelector(".buffer-calc-results");
    if (!resultsContainer) {
      resultsContainer = this.container.createEl("div", { cls: "buffer-calc-results" });
    }
    resultsContainer.empty();
    if (result.errors.length > 0) {
      const errorsContainer = resultsContainer.createEl("div", { cls: "buffer-calc-errors" });
      errorsContainer.createEl("h4", { text: "Errors", cls: "buffer-calc-error-title" });
      result.errors.forEach((error) => {
        errorsContainer.createEl("div", {
          text: error.message,
          cls: "buffer-calc-error-item"
        });
      });
      return;
    }
    resultsContainer.createEl("h4", { text: "Preparation Instructions" });
    if (result.components.length > 0) {
      const instructionsList = resultsContainer.createEl("ol", { cls: "buffer-calc-instructions" });
      result.components.forEach((component, index) => {
        const instruction = instructionsList.createEl("li", { cls: "buffer-calc-instruction-item" });
        const reagentInfo = this.reagentDatabase.getReagentByName(component.reagent.name);
        const displayVolume = component.optimizedVolumeDisplay;
        instruction.createEl("strong", { text: component.reagent.name });
        instruction.createEl("span", { text: `: Add ${displayVolume}` });
        if (component.percentOfTotal) {
          instruction.createEl("span", {
            text: ` (${component.percentOfTotal.toFixed(1)}%)`,
            cls: "buffer-calc-percentage"
          });
        }
        if (reagentInfo) {
          const linksContainer = instruction.createEl("div", { cls: "buffer-calc-links" });
          const links = this.reagentDatabase.getExternalLinks(reagentInfo);
          links.forEach((link) => {
            const linkEl = linksContainer.createEl("a", {
              text: link.name,
              href: link.url,
              cls: "buffer-calc-external-link"
            });
            linkEl.setAttribute("target", "_blank");
            linkEl.setAttribute("rel", "noopener");
          });
        }
      });
      console.log("Solvent display debug:");
      console.log("- result.solventVolume:", result.solventVolume);
      console.log("- Condition (> 0):", result.solventVolume > 0);
      if (result.solventVolume > 0) {
        console.log("- Adding solvent instruction to UI");
        const solventInstruction = instructionsList.createEl("li", { cls: "buffer-calc-instruction-item" });
        const data = this.blockContent.data;
        const solventDisplay = ConversionUtils.optimizeVolumeDisplay(result.solventVolume, data.volumeUnit || this.settings.defaultVolumeUnit);
        console.log("- Solvent display:", solventDisplay);
        solventInstruction.createEl("span", { text: `Add water or buffer to make up to total volume: ${solventDisplay.value.toFixed(this.settings.decimalPlaces)} ${solventDisplay.unit}` });
      } else {
        console.log("- Solvent instruction NOT added (volume <= 0)");
      }
    }
    if (result.warnings.length > 0) {
      const warningsContainer = resultsContainer.createEl("div", { cls: "buffer-calc-warnings" });
      warningsContainer.createEl("h5", { text: "Warnings" });
      result.warnings.forEach((warning) => {
        const warningEl = warningsContainer.createEl("div", {
          text: warning.message,
          cls: `buffer-calc-warning buffer-calc-warning-${warning.severity}`
        });
      });
    }
    if (this.settings.showCalculationSteps && result.calculationSteps && result.calculationSteps.length > 0) {
      const stepsContainer = resultsContainer.createEl("div", { cls: "buffer-calc-steps" });
      stepsContainer.createEl("h5", { text: "Calculation Steps" });
      result.calculationSteps.forEach((step) => {
        const stepEl = stepsContainer.createEl("div", { cls: "buffer-calc-step" });
        stepEl.createEl("strong", { text: `${step.step}. ${step.description}` });
        if (step.formula) {
          stepEl.createEl("div", {
            text: step.formula,
            cls: "buffer-calc-formula"
          });
        }
        stepEl.createEl("div", {
          text: `Result: ${step.result.toFixed(this.settings.decimalPlaces)} ${step.unit}`,
          cls: "buffer-calc-step-result"
        });
      });
    }
    const exportButton = resultsContainer.createEl("button", {
      text: "Export Recipe",
      cls: "buffer-calc-export-button"
    });
    exportButton.addEventListener("click", () => {
      this.exportRecipe(result);
    });
  }
  renderError(message) {
    let resultsContainer = this.container.querySelector(".buffer-calc-results");
    if (!resultsContainer) {
      resultsContainer = this.container.createEl("div", { cls: "buffer-calc-results" });
    }
    resultsContainer.empty();
    resultsContainer.createEl("div", {
      text: `Error: ${message}`,
      cls: "buffer-calc-error"
    });
  }
  async renderStockCalculator() {
    this.container.createEl("div", {
      text: "Stock solution calculator - Implementation coming soon",
      cls: "buffer-calc-placeholder"
    });
  }
  async renderDilutionCalculator() {
    this.container.createEl("div", {
      text: "Dilution calculator - Implementation coming soon",
      cls: "buffer-calc-placeholder"
    });
  }
  exportRecipe(result) {
    if (!result || result.components.length === 0) {
      new import_obsidian2.Notice("No calculation results to export");
      return;
    }
    const data = this.blockContent.data;
    let exportText = `# ${data.name || "Buffer Recipe"}

`;
    exportText += `**Total Volume:** ${data.totalVolume} ${data.volumeUnit || this.settings.defaultVolumeUnit}

`;
    exportText += `## Components

`;
    result.components.forEach((component, index) => {
      exportText += `${index + 1}. **${component.reagent.name}**: ${component.optimizedVolumeDisplay}`;
      if (component.percentOfTotal) {
        exportText += ` (${component.percentOfTotal.toFixed(1)}%)`;
      }
      exportText += `
`;
      exportText += `   - Stock: ${component.stockConcentration} ${component.stockConcentrationUnit}
`;
      exportText += `   - Final: ${component.finalConcentration} ${component.finalConcentrationUnit}
`;
      if (component.lotNumber) {
        exportText += `   - Lot: ${component.lotNumber}
`;
      }
      exportText += `
`;
    });
    if (result.solventVolume > 0) {
      const solventDisplay = ConversionUtils.optimizeVolumeDisplay(result.solventVolume, data.volumeUnit || this.settings.defaultVolumeUnit);
      exportText += `**Solvent**: Add water to ${solventDisplay.value.toFixed(this.settings.decimalPlaces)} ${solventDisplay.unit}

`;
    }
    if (result.warnings.length > 0) {
      exportText += `## Warnings

`;
      result.warnings.forEach((warning) => {
        exportText += `- ${warning.message}
`;
      });
      exportText += `
`;
    }
    exportText += `*Generated by Buffer Calc on ${new Date().toLocaleDateString()}*
`;
    navigator.clipboard.writeText(exportText).then(() => {
      new import_obsidian2.Notice("Recipe exported to clipboard");
    }).catch(() => {
      new import_obsidian2.Notice("Failed to copy recipe to clipboard");
    });
  }
};

// src/main.ts
var BufferCalcPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Buffer Calc plugin");
    await this.loadSettings();
    this.calculationEngine = new CalculationEngine(this.settings);
    this.reagentDatabase = new ReagentDatabase();
    await this.reagentDatabase.initialize();
    this.registerMarkdownCodeBlockProcessor(
      "buffer",
      this.bufferCalcBlockHandler.bind(this, "buffer"),
      100
    );
    this.registerMarkdownCodeBlockProcessor(
      "buffer-calc",
      this.bufferCalcBlockHandler.bind(this, "buffer"),
      100
    );
    this.registerMarkdownCodeBlockProcessor(
      "stock-solution",
      this.bufferCalcBlockHandler.bind(this, "stock"),
      100
    );
    this.registerMarkdownCodeBlockProcessor(
      "dilution",
      this.bufferCalcBlockHandler.bind(this, "dilution"),
      100
    );
    this.settingsTab = new BufferCalcSettingTab(this.app, this);
    this.addSettingTab(this.settingsTab);
    this.addCommand({
      id: "insert-buffer-calc",
      name: "Insert Buffer Calculation",
      callback: () => {
        this.insertBufferCalcBlock();
      }
    });
    this.addCommand({
      id: "open-recipe-manager",
      name: "Open Recipe Manager",
      callback: () => {
        new RecipeManagerModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "insert-saved-recipe",
      name: "Insert Saved Recipe",
      callback: () => {
        new RecipeInsertModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "manage-reagents",
      name: "Manage Custom Reagents",
      callback: () => {
        new ReagentManagerModal(this.app, this).open();
      }
    });
    console.log("Buffer Calc plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Buffer Calc plugin");
  }
  async bufferCalcBlockHandler(blockType, source, el, ctx) {
    try {
      const blockContent = this.parseBlockContent(blockType, source);
      console.log("Parsed block content:", blockContent);
      el.empty();
      el.addClass("buffer-calc-container");
      const ui = new BufferCalcUI(
        el,
        blockContent,
        this.calculationEngine,
        this.reagentDatabase,
        this.settings,
        ctx
      );
      await ui.render();
    } catch (error) {
      console.error("Buffer Calc block handler error:", error);
      el.createEl("div", {
        text: `Error processing buffer calculation: ${error.message}`,
        cls: "buffer-calc-error"
      });
    }
  }
  parseBlockContent(blockType, source) {
    try {
      console.log("Parsing block source:", source);
      if (!source.trim()) {
        console.log("Empty source, using default content");
        return this.getDefaultBlockContent(blockType);
      }
      let parsedData;
      if (source.includes(":") && !source.trim().startsWith("{")) {
        console.log("Parsing as YAML");
        parsedData = this.parseSimpleYAML(source);
      } else {
        try {
          console.log("Parsing as JSON");
          parsedData = JSON.parse(source);
        } catch (e) {
          console.log("Parsing as key-value pairs");
          parsedData = this.parseKeyValuePairs(source);
        }
      }
      console.log("Parsed data:", parsedData);
      console.log("Components type:", typeof parsedData.components, Array.isArray(parsedData.components));
      return {
        type: blockType,
        data: parsedData,
        options: parsedData.options || {}
      };
    } catch (error) {
      console.error("Error parsing block content:", error);
      return this.getDefaultBlockContent(blockType);
    }
  }
  parseSimpleYAML(source) {
    const lines = source.split("\n");
    const result = { components: [] };
    let currentComponent = null;
    let inComponentsSection = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith("#"))
        continue;
      if (trimmedLine === "components:") {
        inComponentsSection = true;
        continue;
      }
      if (trimmedLine.startsWith("-") && inComponentsSection) {
        if (currentComponent) {
          result.components.push(currentComponent);
        }
        currentComponent = {};
        const afterDash = trimmedLine.substring(1).trim();
        if (afterDash.includes(":")) {
          const [key, ...valueParts] = afterDash.split(":");
          const value = valueParts.join(":").trim();
          const cleanKey = key.trim();
          currentComponent[cleanKey] = isNaN(Number(value)) ? value : Number(value);
        }
        continue;
      }
      if (trimmedLine.includes(":")) {
        const [key, ...valueParts] = trimmedLine.split(":");
        const value = valueParts.join(":").trim();
        const cleanKey = key.trim();
        if (currentComponent && inComponentsSection && line.startsWith("    ")) {
          currentComponent[cleanKey] = isNaN(Number(value)) ? value : Number(value);
        } else if (!inComponentsSection || !line.startsWith("    ")) {
          if (cleanKey !== "components") {
            inComponentsSection = false;
            result[cleanKey] = isNaN(Number(value)) ? value : Number(value);
          }
        }
      }
    }
    if (currentComponent) {
      result.components.push(currentComponent);
    }
    if (!Array.isArray(result.components)) {
      result.components = [];
    }
    return result;
  }
  parseKeyValuePairs(source) {
    const result = {};
    const lines = source.split("\n");
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine)
        continue;
      const colonIndex = trimmedLine.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmedLine.substring(0, colonIndex).trim();
        const value = trimmedLine.substring(colonIndex + 1).trim();
        result[key] = isNaN(Number(value)) ? value : Number(value);
      }
    }
    return result;
  }
  getDefaultBlockContent(blockType) {
    const defaultData = blockType === "buffer" ? {
      totalVolume: 1e3,
      volumeUnit: this.settings.defaultVolumeUnit,
      components: []
    } : blockType === "stock" ? {
      reagent: "",
      targetConcentration: 100,
      concentrationUnit: this.settings.defaultConcentrationUnit,
      volume: 10,
      volumeUnit: this.settings.defaultVolumeUnit
    } : {
      initialConcentration: 1e3,
      initialUnit: this.settings.defaultConcentrationUnit,
      steps: []
    };
    return {
      type: blockType,
      data: defaultData
    };
  }
  insertBufferCalcBlock() {
    const activeView = this.app.workspace.getActiveViewOfType(null);
    if (activeView && "editor" in activeView) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      const template = `\`\`\`buffer
name: My Buffer
totalVolume: 1000
volumeUnit: mL
components:
  - name: Tris-HCl
    stockConc: 1
    stockUnit: M
    finalConc: 50
    finalUnit: mM
  - name: NaCl
    stockConc: 5
    stockUnit: M
    finalConc: 150
    finalUnit: mM
\`\`\``;
      editor.replaceRange(template, cursor);
      editor.setCursor(cursor.line + 1, 0);
    } else {
      new import_obsidian3.Notice("Please open a note to insert buffer calculation");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.calculationEngine) {
      this.calculationEngine.updateSettings(this.settings);
    }
    this.app.workspace.trigger("buffer-calc:settings-changed");
  }
};
var RecipeManagerModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Recipe Manager" });
    contentEl.createEl("p", { text: "Recipe management functionality will be implemented here." });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RecipeInsertModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Insert Saved Recipe" });
    contentEl.createEl("p", { text: "Recipe insertion functionality will be implemented here." });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ReagentManagerModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Manage Custom Reagents" });
    contentEl.createEl("p", { text: "Reagent management functionality will be implemented here." });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
